"""
MA Crossover Backtester - Local Version
Simple brute-force parameter search
"""

import numpy as np
import pandas as pd
from itertools import product
from dataclasses import dataclass
from typing import List, Tuple
from pathlib import Path
import time


# Config
DATA_DIR = Path(__file__).parent / "data" / "raw"
TRADING_FEE = 0.001  # 0.1% per trade (Binance standard)


@dataclass
class BacktestResult:
    coin: str
    fast_ma: int
    slow_ma: int
    total_return: float
    num_trades: int
    win_rate: float


def load_price_data(filepath: Path) -> pd.DataFrame:
    """Load price data from parquet file."""
    df = pd.read_parquet(filepath)
    return df[["timestamp", "close"]]


def get_available_coins() -> List[Path]:
    """Find all parquet files in data directory."""
    if not DATA_DIR.exists():
        raise FileNotFoundError(
            f"Data directory not found: {DATA_DIR}\n"
            "Run fetch_data.py first to download data."
        )
    
    files = list(DATA_DIR.glob("*.parquet"))
    if not files:
        raise FileNotFoundError(
            f"No parquet files found in {DATA_DIR}\n"
            "Run fetch_data.py first to download data."
        )
    
    return files


def run_backtest(prices: pd.DataFrame, fast_ma: int, slow_ma: int) -> Tuple[float, int, float]:
    """
    Run single MA crossover backtest.
    Returns: (total_return, num_trades, win_rate)
    """
    df = prices.copy()
    df['fast'] = df['close'].rolling(window=fast_ma).mean()
    df['slow'] = df['close'].rolling(window=slow_ma).mean()
    df = df.dropna()
    
    # Generate signals
    df['signal'] = 0
    df.loc[df['fast'] > df['slow'], 'signal'] = 1   # long
    df.loc[df['fast'] < df['slow'], 'signal'] = -1  # short/exit
    
    # Track trades
    position = 0
    entry_price = 0
    trades = []
    
    for i, row in df.iterrows():
        if row['signal'] == 1 and position == 0:
            position = 1
            entry_price = row['close'] * (1 + TRADING_FEE)
        elif row['signal'] == -1 and position == 1:
            exit_price = row['close'] * (1 - TRADING_FEE)
            pnl = (exit_price - entry_price) / entry_price
            trades.append(pnl)
            position = 0
    
    if len(trades) == 0:
        return 0.0, 0, 0.0
    
    total_return = np.prod([1 + t for t in trades]) - 1
    win_rate = sum(1 for t in trades if t > 0) / len(trades)
    
    return total_return, len(trades), win_rate


def run_parameter_sweep(
    fast_range: List[int],
    slow_range: List[int]
) -> List[BacktestResult]:
    """
    Brute force all parameter combinations.
    This is the part that gets distributed on Azure later.
    """
    results = []
    
    # Get data files
    files = get_available_coins()
    coins = [(f.stem, f) for f in files]
    print(f"Found data: {[c[0] for c in coins]}")
    
    # Generate all jobs
    jobs = [
        (coin_name, coin_path, fast, slow)
        for coin_name, coin_path in coins
        for fast, slow in product(fast_range, slow_range)
        if fast < slow
    ]
    
    print(f"Running {len(jobs)} backtests...")
    start = time.time()
    
    # Cache loaded data
    data_cache = {}
    
    for i, (coin_name, coin_path, fast, slow) in enumerate(jobs):
        if coin_name not in data_cache:
            data_cache[coin_name] = load_price_data(coin_path)
        
        prices = data_cache[coin_name]
        total_return, num_trades, win_rate = run_backtest(prices, fast, slow)
        
        results.append(BacktestResult(
            coin=coin_name,
            fast_ma=fast,
            slow_ma=slow,
            total_return=total_return,
            num_trades=num_trades,
            win_rate=win_rate
        ))
        
        if (i + 1) % 10 == 0:
            print(f"  Completed {i + 1}/{len(jobs)}")
    
    elapsed = time.time() - start
    print(f"Done in {elapsed:.2f}s ({len(jobs)/elapsed:.1f} backtests/sec)")
    
    return results


def main():
    fast_range = [5, 10, 15, 20, 25, 30, 40, 50]
    slow_range = [20, 30, 50, 75, 100, 150, 200, 250]   
    
    results = run_parameter_sweep(fast_range, slow_range)
    results.sort(key=lambda x: x.total_return, reverse=True)
    
    print("\n" + "="*60)
    print("TOP 10 PARAMETER COMBINATIONS")
    print("="*60)
    
    for i, r in enumerate(results[:10]):
        print(f"{i+1:2}. {r.coin:10} | fast={r.fast_ma:3} slow={r.slow_ma:3} | "
              f"return={r.total_return:+7.2%} | trades={r.num_trades:3} | "
              f"win={r.win_rate:.1%}")
    
    print("\n" + "="*60)
    print("WORST 5")
    print("="*60)
    
    for i, r in enumerate(results[-5:]):
        print(f"   {r.coin:10} | fast={r.fast_ma:3} slow={r.slow_ma:3} | "
              f"return={r.total_return:+7.2%} | trades={r.num_trades:3} | "
              f"win={r.win_rate:.1%}")
    
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    returns = [r.total_return for r in results]
    profitable = sum(1 for r in returns if r > 0)
    print(f"Total strategies tested: {len(results)}")
    print(f"Profitable strategies: {profitable} ({profitable/len(results):.1%})")
    print(f"Average return: {np.mean(returns):+.2%}")
    print(f"Best return: {max(returns):+.2%}")
    print(f"Worst return: {min(returns):+.2%}")


if __name__ == "__main__":
    main()